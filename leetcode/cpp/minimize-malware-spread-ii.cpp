/* -- https://leetcode.com/problems/minimize-malware-spread-ii/description/ - */
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

class Solution {
   public:
    // Perfroms BFS starting from all initially infected nodes except the one to be skipped
    // BFS too skips the node to be skipped
    // Returns the total number of visited (infected) nodes
    // O(v + e) -> O(n^2)
    int totalInfected(vector<vector<int>>& adj_list, vector<int>& initial, int to_skip) {
        int n = adj_list.size();

        int num_visited_nodes = 0;
        vector<bool> visited(n, 0);

        // Pushes the node into queue, marks it as visited, and increases the number of visited nodes
        auto visit_node = [&](queue<int>& q, int node) {
            q.push(node);
            visited[node] = true;
            num_visited_nodes++;
        };

        // DO BFS starting from all initially infected, unvisted and not to be skipped nodes
        for (const int& start : initial) {
            if (start == to_skip || visited[start]) {
                continue;
            }

            queue<int> q;
            visit_node(q, start);
            while (!q.empty()) {
                int front = q.front();
                q.pop();
                for (const int& nbr : adj_list[front]) {
                    if (nbr == to_skip) {
                        continue;
                    }

                    if (!visited[nbr]) {
                        visit_node(q, nbr);
                    }
                }
            }
        }
        return num_visited_nodes;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // Convert the graph from adj matrix to adj list (lower time complexity for sparse graphs)
        vector<vector<int>> adj_list(graph.size(), vector<int>());
        for (int i = 0; i < graph.size(); i++) {
            for (int j = 0; j < graph.size(); j++) {
                if (graph[i][j]) {
                    adj_list[i].push_back(j);
                }
            }
        }

        // Iteratively skip each starting node and find how many nodes will be infected using bfs
        // Keep track of the minimum number of infected nodes and the node to be removed
        int node_to_be_removed = -1;
        int minimum_infection_so_far = graph.size() + 1;
        for (const int& skip_node : initial) {
            int infected_nodes = totalInfected(adj_list, initial, skip_node);

            if (infected_nodes < minimum_infection_so_far) {
                minimum_infection_so_far = infected_nodes;
                node_to_be_removed = skip_node;
            } else if (infected_nodes == minimum_infection_so_far && skip_node < node_to_be_removed) {
                node_to_be_removed = skip_node;
            }
        }
        return node_to_be_removed;
    }
};